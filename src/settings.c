/****************************
 * DreamShell ##version##   *
 * settings.c               *
 * DreamShell settings      *
 * Created by SWAT          *
 * http://www.dc-swat.ru    *
 ***************************/

#include <ds.h>

#define DS_SAVE_FN "DSCONFIG.CFG"

static Settings_t current_set;
static int loaded = 0;

const static unsigned short DS_pal[16]= {
	0xF000,0xF655,0xF300,0xFECC,0xFCBB,0xF443,0xFA99,0xF222,
	0xFA88,0xF500,0xF988,0xF100,0xF877,0xF844,0xF700,0xF500
};

const static unsigned char DS_data[32*32/2]= {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x22,0xB0,0x00,0x00,0x00,0x55,0x5B,0x00,0x00,0xB1,0x17,0x00,0x00,0x00,0x00,0x00,
	0xB2,0x22,0x22,0xB0,0x05,0x38,0x63,0x10,0x05,0x3A,0xC4,0x50,0x00,0x00,0x00,0x00,
	0x00,0x00,0xB2,0x29,0x25,0x40,0x07,0x37,0x04,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x22,0x22,0x22,0x22,0xFD,0x4E,0x92,0x88,0x04,0xCB,0xBB,0xBB,0xB0,0x00,0x00,0x00,
	0x00,0xBB,0xBB,0xBB,0xB5,0x42,0x9F,0x14,0x2D,0x34,0xC9,0x22,0x99,0x92,0x22,0x22,
	0x00,0x00,0x00,0x00,0x05,0x40,0x00,0x14,0xBB,0x91,0x43,0x52,0x22,0x99,0x92,0x22,
	0x00,0x00,0x00,0x00,0x05,0x40,0x00,0xC6,0x00,0x00,0xBA,0x42,0x22,0x22,0x22,0x22,
	0x00,0x00,0x00,0x00,0x05,0x40,0x00,0x35,0x00,0x00,0x01,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x05,0x31,0x14,0xA0,0x06,0x15,0x13,0x50,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0B,0x1C,0xC5,0x00,0x05,0xC6,0xA7,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};


Settings_t *GetSettings() {

	if(!loaded) {
		LoadSettings();
	}
	if(!loaded) {
		ResetSettings();
	}
	return &current_set;
}


void SetSettings(Settings_t *settings) {

	if(settings != (Settings_t *)&current_set) {
		memcpy(&current_set, settings, sizeof(current_set));
	}

	loaded = 1;
}


void ResetSettings() {

	Settings_t *cur = &current_set;
	VideoSettings_t *vid = &current_set.video;
	AudioSettings_t *aud = &current_set.audio;
	NetworkSettings_t *net = &current_set.network;
	memset(&current_set, 0, sizeof(current_set));

	vid->bpp = 16;

	vid->tex_width = 1024;
	vid->tex_height = 512;
	vid->tex_filter = -1;

	vid->virt_width = 640;
	vid->virt_height = 480;

	aud->volume = 230;
	aud->sfx_enabled = 1;
	aud->click_enabled = 1;
	aud->hover_enabled = 1;
	aud->startup_enabled = 1;

	net->startup_connect = 0;
	net->startup_ntp = 0;

	strncpy(cur->app, "Main", 4);
	cur->app[4] = '\0';

	strncpy(cur->startup, "/lua/startup.lua", 16);
	cur->startup[16] = '\0';

	cur->version = DS_SETTIGS_VERSION;

	if(loaded) {
		char fn[NAME_MAX];
		char save_name[24];
		maple_device_t *vmu;
		
		snprintf(fn, NAME_MAX, "%s/%s", getenv("PATH"), DS_SAVE_FN);
		fs_unlink(fn);

		for (int i = 0; i < 8; ++i) {
			if (!(vmu = maple_enum_type(i, MAPLE_FUNC_MEMCARD))) {
				break;
			}
			snprintf(save_name, sizeof(save_name),
				"/vmu/%c%c/%s", vmu->port + 'A', vmu->unit + '0', DS_SAVE_FN);
			fs_unlink(save_name);
		}
	}
	else {
		loaded = 1;
	}
}

static int LoadSettingsVMU() {

	char save_name[24];
	maple_device_t *vmu;
	file_t fd;
	int ret = 0;
	Settings_t sets;

	for (int i = 0; i < 8; ++i) {
		if (!(vmu = maple_enum_type(i, MAPLE_FUNC_MEMCARD))) {
			break;
		}

		snprintf(save_name, sizeof(save_name), "/vmu/%c%c/%s",
			vmu->port + 'A', vmu->unit + '0', DS_SAVE_FN);
		fd = fs_open(save_name, O_RDONLY);

		if (fd == FILEHND_INVALID) {
			continue;
		}

		fs_read(fd, &sets, sizeof(Settings_t));

		if (sets.version != DS_SETTIGS_VERSION) {
			dbglog(DBG_DEBUG, "%s: Version mismatch for %s\n", __func__, save_name);
			fs_close(fd);
			continue;
		}

		memcpy(&current_set, &sets, sizeof(current_set));
		fs_close(fd);
		ret = 1;
		break;
	}

	return ret;
}

static int LoadSettingsFile(const char *filename) {

	Settings_t sets;
	file_t fd;
	ssize_t res;

	fd = fs_open(filename, O_RDONLY);

	if(fd == FILEHND_INVALID) {
		return 0;
	}

	if(fs_total(fd) != sizeof(Settings_t)) {
		fs_close(fd);
		return 0;
	}

	res = fs_read(fd, &sets, sizeof(Settings_t));
	fs_close(fd);

	if (res != sizeof(Settings_t)) {
		return 0;
	}

	if (sets.version != DS_SETTIGS_VERSION) {
		dbglog(DBG_DEBUG, "%s: Version mismatch for %s\n", __func__, filename);
		return 0;
	}

	memcpy(&current_set, &sets, sizeof(Settings_t));
	return 1;
}

int LoadSettings() {
	char fn[NAME_MAX];
	loaded = LoadSettingsVMU();

	if (!loaded) {
		snprintf(fn, NAME_MAX, "%s/%s", getenv("PATH"), DS_SAVE_FN);
		loaded = LoadSettingsFile(fn);
	}

	if(!loaded) {
		ResetSettings();
	}
	return loaded;
}

static int SaveSettingsVMU() {

	char save_name[24];
	maple_device_t *vmu;
	file_t fd;
	int ret = 0;
	int pkg_size;
	vmu_pkg_t pkg;
	uint8_t *pkg_out;

	memset(&pkg, 0, sizeof(pkg));

	strcpy(pkg.desc_short, getenv("VERSION"));
	strcpy(pkg.desc_long, "DreamShell Settings");
	strcpy(pkg.app_id, "DreamShell");

	pkg.icon_cnt = 1;
	pkg.icon_anim_speed = 0;
	memcpy(pkg.icon_pal, DS_pal, 32);
	pkg.icon_data = (uint8 *)DS_data;
	pkg.eyecatch_type = VMUPKG_EC_NONE;
	pkg.data_len = sizeof(current_set);
	pkg.data = (void *)&current_set;

	if(vmu_pkg_build(&pkg, &pkg_out, &pkg_size) < 0) {
		return ret;
	}

	for (int i = 0; i < 8; i++) {
		if (!(vmu = maple_enum_type(i, MAPLE_FUNC_MEMCARD))) {
			break;
		}

		snprintf(save_name, sizeof(save_name),
			"/vmu/%c%c/%s", vmu->port + 'A', vmu->unit + '0', DS_SAVE_FN);

		fs_unlink(save_name);

		if((vmufs_free_blocks(vmu) * 512) < pkg_size) {
			continue;
		}

		fd = fs_open(save_name, O_WRONLY | O_META);

		if (fd == FILEHND_INVALID) {
			continue;
		}

		fs_write(fd, pkg_out, pkg_size);
		fs_close(fd);

		vmu_beep_raw(vmu, 0x000065f0); // Turn on Beep
		thd_sleep(500);
		vmu_beep_raw(vmu, 0x00000000); // Turn off Beep
		ret = 1;
		break;
	}

	free(pkg_out);
	return ret;
}

static int SaveSettingsFile(const char *filename) {

	file_t fd;
	ssize_t res;

	fd = fs_open(filename, O_WRONLY | O_TRUNC | O_CREAT);

	if(fd == FILEHND_INVALID) {
		dbglog(DBG_DEBUG, "%s: Can't open for write %s\n", __func__, filename);
		return 0;
	}

	res = fs_write(fd, &current_set, sizeof(current_set));
	fs_close(fd);

	return (res <= 0 ? 0 : 1);
}

int SaveSettings() {

	char fn[NAME_MAX];

	if(current_set.version != DS_SETTIGS_VERSION) {
		current_set.version = DS_SETTIGS_VERSION;
	}

	if(SaveSettingsVMU()) {
		return 1;
	}

	snprintf(fn, NAME_MAX, "%s/%s", getenv("PATH"), DS_SAVE_FN);
	return SaveSettingsFile(fn);
}

int GetVolumeFromSettings() {
    Settings_t *settings = GetSettings();
    if(!settings) {
        return -1;
    }
    return settings->audio.volume;
}
