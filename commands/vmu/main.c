/* DreamShell ##version##

   vmu.c
   Copyright (C) 2009-2016 SWAT
*/

#include "ds.h"


const static unsigned short DS_pal[16]= {
	0xF000,0xF655,0xF300,0xFECC,0xFCBB,0xF443,0xFA99,0xF222,
	0xFA88,0xF500,0xF988,0xF100,0xF877,0xF844,0xF700,0xF500
};

const static unsigned char DS_data[32*32/2]= {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x22,0xB0,0x00,0x00,0x00,0x55,0x5B,0x00,0x00,0xB1,0x17,0x00,0x00,0x00,0x00,0x00,
	0xB2,0x22,0x22,0xB0,0x05,0x38,0x63,0x10,0x05,0x3A,0xC4,0x50,0x00,0x00,0x00,0x00,
	0x00,0x00,0xB2,0x29,0x25,0x40,0x07,0x37,0x04,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
	0x22,0x22,0x22,0x22,0xFD,0x4E,0x92,0x88,0x04,0xCB,0xBB,0xBB,0xB0,0x00,0x00,0x00,
	0x00,0xBB,0xBB,0xBB,0xB5,0x42,0x9F,0x14,0x2D,0x34,0xC9,0x22,0x99,0x92,0x22,0x22,
	0x00,0x00,0x00,0x00,0x05,0x40,0x00,0x14,0xBB,0x91,0x43,0x52,0x22,0x99,0x92,0x22,
	0x00,0x00,0x00,0x00,0x05,0x40,0x00,0xC6,0x00,0x00,0xBA,0x42,0x22,0x22,0x22,0x22,
	0x00,0x00,0x00,0x00,0x05,0x40,0x00,0x35,0x00,0x00,0x01,0x40,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x05,0x31,0x14,0xA0,0x06,0x15,0x13,0x50,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x0B,0x1C,0xC5,0x00,0x05,0xC6,0xA7,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};



int main(int argc, char *argv[]) { 

	if(argc < 2) {
		ds_printf("Usage: %s option args...\n\n"
				"Options: \n"
				" -c, --convert      -Convert file\n"
				" -d, --dump         -Dump VMU\n", argv[0]);
		ds_printf(" -r, --restore      -Restore dump\n"
				" -s, --size         -Set VMU size(in blocks)\n"
				" -p, --printinfo    -Print VMU info\n\n");
		ds_printf("Arguments: \n"
				" -a, --address      -VMU address\n"
				" -n, --normal       -Convert to normal file\n"
				" -v, --vmu          -Convert to VMU file\n");
		ds_printf(" -i, --info         -VMU file description\n"
				" -f, --file         -In file\n"
				" -o, --out          -Out file\n\n");
		ds_printf("Examples: %s -c -v -f /cd/file.txt -o /vmu/a1/DSFILE00.DSV -i Test vmu file\n"
				"          %s --convert --normal --file /vmu/a1/DSFILE00.DSV --out /ram/file.txt\n"
				"          %s -d -a A1 -o /ram/dump.vmd\n"
				"          %s --restore --address A1 --file /ram/dump.vmd\n"
				"          %s -p -s 240\n", argv[0], argv[0], argv[0], argv[0], argv[0]);
		return CMD_NO_ARG;
	}

	int port, unit, i, siz;
	maple_device_t *dev = NULL;
	uint8 *vmdata;

	file_t f;
	file_t fd;

	int convert = 0, dump = 0, restore = 0, normal = 0, vmu = 0, printinf = 0;
	int vmsize = 0;
	char *file = NULL, *out = NULL, *addr = NULL, **preinfo = NULL;

	struct cfg_option options[] = {
		{"convert",   'c', NULL, CFG_BOOL, (void *) &convert,  0},
		{"dump",      'd', NULL, CFG_BOOL, (void *) &dump,     0},
		{"restore",   'r', NULL, CFG_BOOL, (void *) &restore,  0},
		{"printinfo", 'p', NULL, CFG_BOOL, (void *) &printinf, 0},
		{"size",      's', NULL, CFG_INT,  (void *) &vmsize,   0},
		{"address",   'a', NULL, CFG_STR,  (void *) &addr,     0},
		{"normal",    'n', NULL, CFG_BOOL, (void *) &normal,   0},
		{"vmu",       'v', NULL, CFG_BOOL, (void *) &normal,   0},
		{"info",      'i', NULL, CFG_STR+CFG_MULTI+CFG_LEFTOVER_ARGS, (void *) &preinfo, 0},
		{"file",      'f', NULL, CFG_STR,  (void *) &file,     0},
		{"out",       'o', NULL, CFG_STR,  (void *) &out,      0},
		CFG_END_OF_LIST
	};

	CMD_DEFAULT_ARGS_PARSER(options);

	if(dump || restore || vmsize > 0) {
		 
		if(addr == NULL) {
			ds_printf("DS_ERROR: Too few arguments. (VMU address)\n");
			return CMD_NO_ARG; 
		}

		port = addr[0] - 'A';
		unit = addr[1] - '0';
		dev = maple_enum_dev(port, unit);

		if (!dev || !(dev->info.functions & MAPLE_FUNC_MEMCARD)) {
			ds_printf("DS_ERROR: No device, or device not a VMU\n");
			return CMD_ERROR;
		}
	}

	if(printinf || vmsize > 0) {
		
		vmu_root_t vmroot;
		memset(&vmroot, 0, sizeof(vmu_root_t));
		vmufs_root_read(dev, &vmroot);

		if(printinf) {
			ds_printf("\n    VMU (%s) Info: \n\n"
					" Type: %s\n"
					" FAT location: %d\n"
					" FAT size in blocks: %d\n"
					" Directory location: %d\n"
					" Directory size in blocks: %d\n"
					" Icon shape for this VMS: %d\n"
					" Number of user blocks: %d\n", addr, vmroot.use_custom ? "custom" : "standard",
					vmroot.fat_loc, vmroot.fat_size, vmroot.dir_loc, 
					vmroot.dir_size, vmroot.icon_shape, vmroot.blk_cnt);
		}

		if(vmsize > 0) {
			ds_printf("%sDS_PROCESS: Current size %d blocks, set to %d blocks...\n", 
					printinf ? "\n" : "", (int)vmroot.blk_cnt, vmsize);
			vmroot.blk_cnt = (uint16)vmsize;
			vmufs_root_write(dev, &vmroot);
		}
	}

	if(dump) {

		if(out == NULL) {
			ds_printf("DS_ERROR: Too few arguments. (out file)\n");
			return CMD_NO_ARG; 
		}

		f = fs_open(out, O_WRONLY | O_CREAT | O_TRUNC);

		if(f < 0) {
			ds_printf("DS_ERROR: Can't open %s", out);
			return CMD_ERROR;
		}

		vmdata = (uint8 *) malloc(512);
		memset(vmdata, 0, 512);

		ds_printf("DS_PROCESS: %s dumping...\n", addr);

		for (i = 0; i < 256; i++) {
			if (vmu_block_read(dev, i, vmdata) < 0) {
				ds_printf("DS_ERROR: Failed to read block %d\n", i);
				fs_close(f);
				free(vmdata);
				return CMD_ERROR;
			}
			fs_write(f, vmdata, 512);
		}

		fs_close(f);
		free(vmdata);
		ds_printf("DS_OK: Dumping complete.\n"); 
		return CMD_OK;
	}

	
	if(restore) {

		if(file == NULL) {
			ds_printf("DS_ERROR: Too few arguments. (file)\n");
			return CMD_NO_ARG; 
		}

		f = fs_open(file, O_RDONLY);

		if(f < 0) {
			ds_printf("DS_ERROR: Can't open %s", file);
			return CMD_ERROR; 
		}

		vmdata = (uint8 *) malloc(512);
		memset(vmdata, 0, 512);

		i = 0; 
		ds_printf("DS_PROCESS: Restore %s to %s...\n", file, addr);

		while((siz = fs_read(f, vmdata, 512)) > 0) {
			if(vmu_block_write(dev, i, vmdata) < 0) {
				ds_printf("DS_ERROR: Failed to write block %d\n", i);
				fs_close(f);
				free(vmdata);
				return CMD_ERROR;
			}
			i++;
		}

		fs_close(f);
		free(vmdata);
		ds_printf("DS_OK: Restore complete.\n");
		return CMD_OK;
	}

	if(convert) {

		uint8 *pkg_out;
		vmu_pkg_t pkg;
		int pkg_size;
		char info[32];

		if(out == NULL || file == NULL) {
			ds_printf("DS_ERROR: Too few arguments. \n");
			return CMD_NO_ARG;
		}

		f = fs_open(file, O_RDONLY);

		if(f < 0) {
			ds_printf("DS_ERROR: Can't open %s\n", file);
			return CMD_ERROR;
		} 

		fd = fs_open(out, O_WRONLY | O_TRUNC | O_CREAT | O_META);

		if(fd < 0) {
			ds_printf("DS_ERROR: Can't open %s\n", out);
			return CMD_ERROR;
		} 

		siz = fs_total(f); 
		vmdata = (uint8 *) memalign(32, siz); 
		fs_read(f, vmdata, siz); 
		fs_close(f); 

		if(vmu) {

			ds_printf("DS_PROCESS: Convert %s to VMU file...\n", file);
			strcpy(pkg.desc_short, "DreamShell File");
			memset(info, 0, sizeof(info));

			if(preinfo == NULL) {

				strcpy(pkg.desc_long, "No description");

			} else {

				strcpy(info, preinfo[0]);
				strcat(info, " ");

				for(i = 1; preinfo[i]; i++) {
					strcat(info, preinfo[i]);
					strcat(info, " ");
				}

				strcpy(pkg.desc_long, info);
			}

			strcpy(pkg.app_id, "DreamShell File");
			pkg.icon_cnt = 1;
			pkg.icon_anim_speed = 0;
			memcpy(pkg.icon_pal, DS_pal, 32);
			pkg.icon_data = (uint8 *)DS_data;
			pkg.eyecatch_type = VMUPKG_EC_16BIT; //VMUPKG_EC_NONE;
			pkg.data_len = siz;
			pkg.data = vmdata;

			vmu_pkg_build(&pkg, &pkg_out, &pkg_size);
			fs_unlink(out);
			fs_write(fd, pkg_out, pkg_size);
			fs_close(fd);

			free(vmdata);
			free(pkg_out);
			return CMD_OK;
		} 

		if(normal) { 

			ds_printf("DS_PROCESS: Convert %s to normal file...\n", file);
			vmu_pkg_parse(vmdata, siz, &pkg);
			fs_write(fd, pkg.data, pkg.data_len);
			fs_close(fd);
			free(vmdata);
			return CMD_OK;
		}

		ds_printf("DS_ERROR: Too few arguments. (convert to?)\n");
		return CMD_OK;
	}

	if(!printinf || vmsize == 0) {
		ds_printf("DS_ERROR: There is no option.\n");
	}

	return CMD_OK;
}
