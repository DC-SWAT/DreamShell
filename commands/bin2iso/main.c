/* BIN2ISO (C) 2000 by DeXT
This is a very simple utility to convert a BIN image
(either RAW/2352 or Mode2/2336 format) to standard ISO format (2048 b/s).

Structure of images are as follows:
Mode 1 (2352): Sync (12), Address (3), Mode (1), Data (2048), ECC (288)
Mode 2 (2352): Sync (12), Address (3), Mode (1), Subheader (8), Data (2048), ECC (280)
Mode 2 (2336): Subheader (8), Data (2048), ECC (280)

Mode 2 / 2336 is the same as Mode 2 / 2352 but without header (sync+addr+mode)
Sector size is detected by the presence of Sync data.
Mode is detected from Mode field.

Tip for Mac users: for Mode 2 tracks preserve Subheader.
(sub 8 from seek_header and write 2056 bytes per sector)
Changelog:
2000-11-16 - Added mode detection for RAW data images (adds Mode2/2352 support)
2007-03-13 - Added input validation checks (Magnus-swe).

/*
[COPY] --- T2-COPYRIGHT-NOTE-BEGIN ---
[COPY] This copyright note is auto-generated by ./scripts/Create-CopyPatch.
[COPY] 
[COPY] T2 SDE: package/.../bin2iso/bin2iso.desc
[COPY] Copyright (C) 2006 The T2 SDE Project
[COPY] 
[COPY] More information can be found in the files COPYING and README.
[COPY] 
[COPY] This program is free software; you can redistribute it and/or modify
[COPY] it under the terms of the GNU General Public License as published by
[COPY] the Free Software Foundation; version 2 of the License. A copy of the
[COPY] GNU General Public License can be found in the file COPYING.
[COPY] --- T2-COPYRIGHT-NOTE-END ---
[I] A Bin to ISO converter
[T] The command line program bin2iso converts BIN image files to
[T] standard ISO image files.
[U] http://mange.dynalias.org/linux/bin2iso/
[A] DeXT <de_xt@hotmail.com>
[M] Nagy Karoly Gabriel <karasz@x5.ro>
[C] extra/tool
[L] OpenSource
[S] Stable
[V] 0.4
[D] http://mange.dynalias.org/linux/bin2iso/
[X] Copyright recieved from:
[X] http://svn.exactcode.de/t2/trunk/package/filesystem/bin2iso/bin2iso.desc
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ds.h"

#define MAX_FILENAME_LENGTH 20000

/* Uncomment the following line for MAC */
// #define MAC TRUE



int main(int argc, char **argv)
{
    FILE  *fdest, *fsource;
    long  i, source_length;
    char  buf[2352], destfilename[MAX_FILENAME_LENGTH+10];
    int   seek_header, seek_ecc, sector_size;
    const char SYNC_HEADER[12] = { 0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0 };

    if(argc < 2)
    {
   		ds_printf("Usage: bin2iso image.bin [image.iso]\n");
		return CMD_NO_ARG; 
    }

    for(i=1; argv[i]!='\0'; i++)
    if(strlen(argv[i]) > MAX_FILENAME_LENGTH)
    {
		ds_printf("DS_ERROR: Filename too long.\n\nUsage is: bin2iso image.bin [image.iso]\n");
		return CMD_ERROR;
    }

    if(argc >= 3)
	strcpy(destfilename, argv[2]);
    else
    {
   	strcpy(destfilename, argv[1]);

   	if(strlen(argv[1]) < 5 || strcmp(destfilename+strlen(argv[1])-4, ".bin"))
	    strcpy(destfilename+strlen(argv[1]), ".iso");
   	else
	    strcpy(destfilename+strlen(argv[1])-4, ".iso");
    }

    if((fsource=fopen(argv[1],"rb"))==NULL)
    {
		ds_printf("DS_ERROR: Source file doesnt exist.\n\nUsage is: bin2iso image.bin [image.iso]\n");
		return CMD_ERROR;
    }
    
    if((fdest=fopen(destfilename,"wb"))==NULL)
    {
		ds_printf("DS_ERROR: Cant write destination file.\n\nUsage is: bin2iso image.bin [image.iso]\n");
		return CMD_ERROR;
    }

    fread(buf, sizeof(char), 16, fsource);

    if(memcmp(SYNC_HEADER, buf, 12))
    {
	#ifdef MAC
	    /* MAC */
	    seek_header = 0;
	    seek_ecc    = 280;
	    sector_size = 2336; /* Mode 2 / 2336 */
	#else
	    /* Linux and others */
	    seek_header = 8;
	    seek_ecc    = 280;
	    sector_size = 2336; /* Mode 2 / 2336 */
	#endif
    }
    else
    switch(buf[15])
    {
	case 2:
	    #ifdef MAC
	        /* MAC */
		seek_header = 16;
		seek_ecc    = 280;     
		sector_size = 2352; /* Mode 2 / 2352 */
	    #else
		/* Linux and others */
		seek_header = 24;
		seek_ecc    = 280;     
		sector_size = 2352; /* Mode 2 / 2352 */
	    #endif
	    break;
	case 1:
	    seek_header = 16;	
	    seek_ecc = 288;
	    sector_size = 2352; /* Mode 1 / 2352 */
	    break;
	default:
	    ds_printf("DS_ERROR: Unsupported track mode");
	    return CMD_ERROR;
    }
    fseek(fsource, 0L, SEEK_END);
    source_length = ftell(fsource)/sector_size;
    fseek(fsource, 0L, SEEK_SET);

    for(i=0; i<source_length; i++)
    {
	fseek(fsource, seek_header, SEEK_CUR);
	#ifdef MAC
	    /* MAC */
	    fread(buf, sizeof(char), 2048, fsource); /* Mac: change to 2056 for Mode 2 */
	    fwrite(buf, sizeof(char), 2048, fdest);  /* same as above */
	#else
	    /* Linux and others */
	    fread(buf, sizeof(char), 2048, fsource);
	    fwrite(buf, sizeof(char), 2048, fdest);
	#endif
	
	fseek(fsource, seek_ecc, SEEK_CUR);
    }
    fclose(fdest);
    fclose(fsource);

    return CMD_OK; 
}
